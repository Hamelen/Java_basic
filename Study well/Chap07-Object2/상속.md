# 상속
### 1-1. 상속의 정의와 장점
* 상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
```
class Child extends Parent{
    
}
```
* 상속해주는 클래스 : 조상 클래스, 부모 클래스, 상위 클래스, 기반 클래스
* 상속 받는 클래스 : 자식 클래스, 하위 클래스, 파생된 클래스
* 장점: 같은 내용을 여러 클래스에 중복적으로 추가해야 하는 경우 상속관계를 이용하면 중복을 최소화할 수 있다

### 1-1. 클래스간의 관계 - 포함관계
```
class Circle {
    int x;
    int y;
    int r;
}
```
```
class Point {
    int x;
    int y;
}
```
* 다음과 같이 다른 클래스를 멤버변수로 선언하여 포함시키면 간결해진다.
```
class Circle {
    Point c =new Point();
    int r;
}
```

### 1-2. 단일 상속
* C++에서는 여러 조상 클래스로부터 상속 가능(다중 상속)
* 자바에서는 오직 단일상속을 허용

<br>

## 2. 오버라이딩이란?
* 조상 클래소루벝 상속받은 메서드의 내용을 변경하는 것
* 오버로딩과의 차이점 인지하고 구별할 것

### 2-1. 오버라이딩의 조건
```
자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
- 이름이 같아야 한다
- 매개변수가 같아야 한다
- 반환타입이 같아야 한다
```
1. 접근 제어자는 클래스의 메서드보다 좁은 범위로 변경할 수 없다
2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다
3. 인스턴스 메서드를 static메서드로 또는 그 반대로 변경할 수 없다

### 2-2. 오버로딩vs오버라이딩
```
오버로딩 : 기존에 없는 새로운 메서드를 정의하는 것
오버라이딩 : 상속받은 메서드의 내용을 변경하는 것
```

### 2-3. super
* super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수

### 2-4. super() - 조상 클래스의 생성자
* 앞서 배운 this()는 무엇이었는가?
* super()는 조상 클래스의 생성자를 호출하는데 사용된다.
* 자손의 멤버와 조상의 멥버가 모두 합쳐진 하나의 인스턴스가 생성된다


<br>

## 3. package와 import
### 3-1. 패키지
* 패키지란 클래스의 묶음
* 패키지에는 클래스 또는 인터페이스를 포함시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있다

### 3-2. 패키지의 선언
```
package 패키지명;
```

### 3-3. import문
* 단축키 'ctrl+shift+o' 로 패키지 명시 가능
  

## 제어자(modifier)
### 4-1. 제어자란?
* 제어자는 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다
```
접근 제어자 : public, protected, default, private
그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
```
### 4-2. static - 클래스의, 공통적인
>static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭

### 4-3. final - 마지막의, 변경될 수 없는
>final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수

### 4-4. 추상의, 미완성의 
>abstract가 사용될 수 있는 곳 - 클래스, 메서드

### 4-5. 접근 제어자(access modifier)
```
접근제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자
private : 같은 클래스 내에서만 접근이 가능하다
default : 같은 패키지 내에서만 접근이 가능하다
protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다
public : 접근 제한이 전혀 없다
```

* 사용하는 이유
 - 외부로부터 데이터를 보호하기 위해서
 - 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
  
### 4-6. 제어자의 조합
대상| 사용가능한 제어자
---|---
클래스| public, (default), final, abstract
메서드| 모든 접근 제어자, final, abstract, static
멤버변수| 모든 접근 제어자, final, static
지역변수| final

1. 메서드에 static과 abstract를 함께 사용할 수 없다
2. 클래스에 abstract와 final을 동시에 사용할 수 없다
3. abstract메서드의 접근 제어자가 private일 수 없다
4. 메서드에 private과 final을 같이 사용할 필요는 없다


## 5.다형성(polymorphism)
```
조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다
반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다
```

### 5-1. 참조변수의 형변환
```
자손타입->조상타입 : 형변환 생략가능
자손타입<-조상타입 : 형변환 생략불가
```
### 5-2. instanceof연산자
* 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
* 결과가 true라면 검사한 타입으로 형변환이 가능하단 것
* 멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손 타입의 참조변수를 사용했을 때에는 자손 클래스에 선언된 멤버변수가 사용된다
* 그래서 static메서드는 반드시 참조변수가 아닌 '클래스이름.메서드()'로 호출해야 한다
 
### 5-3. 여러 종류의 객체를 배열로 다루기 
* product클래스가 Tv, Computer, Audio클래스의 조상일 때, 다음과 같이 할 수 있다
```
Product p1 = new Tv();
Product p2 = new Computer();
Product p3 = new Audio();
```
* 이때, 위의 코드를 아래처럼 참조변수 배열로 처리할 수 있다
```
Product p[] =new Product[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```


## 6. 추상 클래스(abstract class)
*. 설계도에 비유해서 설명(미완성 설계도)
*. 서로 다른 설계도를 그리는 것보다는 미완성 설계도에다가 개별적인 차별점을 추가해서 각각의 설계도를 완성하고 제품을 만드는 것이 훨씬 효율적임

### 6-1. 추상 메서드
* 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨둔 것이 추상메서드이다

### 6-2. 추상클래스의 작성
* 추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
* 구체화 : 상속을 통해 클래스를 구현, 확장하는 작업

# 7. 인터페이스(interface)
* 인터페이스란 일종의 추상클래스다
* 인터페이스는 추상클래스처럼 추상메서드를 갖지 않지만 추상 클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다
* 오직 추상메서드와 상수만을 멤버로 가질 수 있다

### 7-1. 선언
```
interface 인터페이스이름{
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수목록);
}
```
* 일반적인 클래스의 멤버들과 달리 인터페이스의 멤버들은 다음과 같은 제약사항이 있다
  - 모든 멤버변수는 public static final이어야 하며, 이를 생략할 수 있다
  - 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.
   (단, static메서드와 디폴트 메서드는 예외(JDK1.8부터))

> 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속이 가능하다

### 7-2. 인터페이스의 구현
* 인터페이스도 추상 클래스처럼 그 자체로는 인스턴스를 생성할 수 없다   
* 추상클래스가 상속을 통해 추상메서드를 완성하는 것처럼 인터페이스도 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 한다
```
class 클래스이름 implements 인터페이스이름{
    //인터페이스에 정의된 추상메서드를 구현해야 한다
}

class Fighter implement Fightable {
    public void move(int x, int y) {/*내용 생략*/}
    public void attack(Unit u)  {/*내용 생략*/}
}
```

>*참고 인터페이스의 이름에는 주로 Fightable과 같이 able로 끝나는 것들이 많은데, 그 이유는 어떠한 기능 또는 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해서이다. 물론 모든 인터페이스의 이름이 반드시 able로 끝나는 것은 아니다

<br>

# 8. 내부 클래스(inner class)
### 8-1. 내부 클래스란
```
내부 클래스의 장점
 - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다
 - 코드의 복잡성을 줄일 수 있다(캡슐화)
```
### 8-2. 내부 클래스의 종류와 특징 
내부 클래스|특 징
---|---
인스턴스 클래스| 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다
스태틱 클래스| 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. 주로 외부 클래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언된다
지역 클래스| 외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다
익명 클래스| 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스

### 8-3. 내부 클래스의 선언
* 변수처럼 선언된 위치에 따라 나뉘며, 각 내부 클래스의 선언위치에 따라 같은 선언위치의 변수와 동일한 유효범위(scope)와 접근성(accessibility)을 갖는다
```
class Outer {
    class InstanceInner {}
    static class StaticInner {}

    void myMethod(){
        class LocalInner {}
    }
}
```
* 내부 클래스도 클래스이기 때문에 abstract나 final과 같은 제어자를 사용할 수 있을 뿐만 아니라, 멤버변수들처럼 private,protected과 접근제어자도 사용이 가능하다
  
### 8-4. 익명 클래스(anonymous class)
```
new 조상클래스이름() {
    // 멤버 선언
}

또는

new 구현인터페이스이름() {
    // 멤버 선언
}
```
* 다른 내부 클래스들과는 달리 이름이 없다
* 클래스의 선언과 객체의 생성을 동시에 하기 떄문에 단 한번만 사용
* 하나의 객체만을 생성하는 일회용 클래스
* 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다