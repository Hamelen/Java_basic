# 객체 지향 언어
1. 코드의 재사용성이 높다
2. 코드의 관리가 용이하다
3. 신뢰성이 높은 프로그래밍을 가능하게 한다

### 1. 객체와 인스턴스
* 클래스의 정의 : 클래스란 객체를 정의해놓은 것
* 용도 : 클래스는 객체를 생성하는데 사용된다

* 객체의 정의 : 실제로 존재하는 것, 사물 또는 개념
* 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름

* 인스턴스화(instantiate) : 클래스로부터 객체를 만드는 과정
* 인스턴스(instance) : 어떤 클래스로부터 만들어진 객체

### 2. 구성요소
* 속성(propety) 멤버변수, 특성, 필드, 상태
* 기능(function) 메서드, 함수, 행위
  
인스턴스의 생성과 사용
```
클래스명 변수명;  //클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명(); //클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t;     //Tv클래스 타입의 참조변수 t를 선언
t = new Tv();     //Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
```
* 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다

### 3. 클래스란
* 클래스란 '객체를 생성하기 위한 틀'이며, 속성과 기능으로 정의되어 있다
* 하지만 이는 객체지향이론의 관점에서 내린 정의
* 프로그래밍적인 관점에서 클래스는 '데이터와 함수의 결합'이다
  >변수->배열->구조체->클래스
```
1. 변수 : 하나의 데이터를 저장할 수 있는 공간
2. 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. 클래스 : 데이터와 함수의 결합(구조체+함수)
```

### 4. 선언 위치에 따른 변수의 종류
```
class Variables
{
    int iv;        //인스턴스 변수
    static in cv; //클래스 변수(static 변수, 공유변수)
    
    void method()
    {

        int lv= 0;  //지역 변수
    }
}
```


변수의 종류| 선언위치| 생성시기
--|--|--
클래스변수|클래스 영역|클래스가 메모리에 올라갈 때
인스턴스변수|클래스 영역|인스턴스가 생성되었을 때
지역변수|클래스 영역 이외의 영역(메서드, 생성자, 초기화 블럭 내부)|변수 선언문이 수행되었을 때
1. 클래스변수 
* 클래스변수를 선언하는 방법은 인스턴스변수 앞에 static을 붙이기만 하면 된다. 
* 클래스는 모든 인스턴스가 공통된 저장공간(변수)를 공유하게 된다
* public을 앞에 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 '전역변수(global variable)'의 성격을 갖는다 

2. 인스턴스변수
* 클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다
* 인스턴스는 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다

3. 지역변수
* 메서드 내에 선언되어 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸되어 사용할 수 없게 된다


# 메서드
* 메서드는 '특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것'이다
* 기본적으로 수학의 함수와 유사하며, 어떤 값을 입력하면 이 값으로 작업을 수행해서 결과를 반환한다
* 메서드를 사용하는 이유
* 1. 높은 재사용성(reusability)
* 2. 중복된 코드의 제거
* 3. 프로그램의 구조화 
  
### 1. 메서드의 선언과 구현
1. 메서드 선언부(method declaration)
   * 메서드 선언부는 '메서드의 이름', '매개변수 선언', '반환타입'으로 구성
   * 작업을 수행하기 위해 어떤 값들을 필요로 하고, 작업의 결과로 어떤 타입의 결과를 반환하는지에 대한 정보 제공

2. 매개변수 선언(parameter declaration)
   * 메서드가 작업을 수행하는데 필요한 값들을 제공받기 위한 것
   * 필요한 값의 개수만큼 변수를 선언한다

3. 반환타입(return type)
   * 메서드의 작업수행 결과(출력)인 반환값(return value)의 타입을 적는다
   * 반환값이 없는 경우 'void'(아무 것도 없음)를 적어야 한다

4. 메서드의 구현부(method body)
   * return문
   * 메서드의 반환타입이 void가 아닌 경우, 구현부{}안에 'return 반환값'이 반드시 포함된다
   * 이 값의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 한다

### 2. 메서드의 호출
* 메서드를 호출하는 방법은 다음과 같다

``` 
메서드이름(값1,값2,...); //메서드를 호출하는 방법
print99danAll();    //void print99danAll()을 호출
int result = add(3,5)
```

### 3. JVM의 메모리 구조
* 응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리
  1. 메서드 영역(method area)
  2. 힙(heap)
  3. 호출스택(call stack 또는 execution stack)
* 메서드 영역 : JVM은 해당 클래스의 클래스 파일(*.class)을 읽어서 분석하여 클래스에 대한 정보를 이곳에 저장한다
* 힙 : 인스턴스가 생성되는 공간
* 호출스택 : 메서드의 작업에 필요한 메모리 공간 제공. 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용

### 4. 기본형 매개변수와 참조형 매개변수
* 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다
* 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다
* 참조형 매개변수를 활용하면 반환값이 없어도 메서드의 실행 결과를 얻어올 수 있다
  
### 5. 재귀 호출
* 메서드의 내부에서 메서드 자신을 다시 호출하는 것을 '재귀호출(recursive call)'이라 하고, 재귀 호출을 하는 메서드를 '재귀 메서드'라 한다
```
void method() {
     method();
}
```
* 재귀호출은 반복문과 유사한 점이 많으며, 대부분은 반복문으로 작성 가능
```
void method(int n) {
    if(n==0)    return;

    System.out.println(n);
    method(--n);
}
```
```
void method(int n){
    while(n!=0){
        System.out.println(n--);
    }
}
```
* 반복문과 달리, 재귀호출은 비효율적이지만 간결하게 작성이 가능하다


### 6. 클래스 메서드(static)와 인스턴스 메서드
* 메서드 앞에 static이 붙으면 클래스 메서드이다
* 클래스 메서드도 클래스변수처럼 객체를 생성하지 않고도 '클래스이름.메서드이름(매개변수)'와 같은 식으로 호출이 가능
* 반면에 인스턴스 메서드는 반드시 객체를 생성해야 호출 가능 

>정리
```
1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다
2. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다
3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다(인스턴스변수는 인스턴스가 반드시 존재해야만 사용 가능, 반대로 인스턴스변수나 인스턴스메서드에서는 static이 붙은 멤버들을 사용할 수 있다)
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다

