 
----- 중간프로젝트 개발일지 ----------

08월 20일

1. 환불 규정

2. 결제 수단이 호스트별로 다를 수도 있다

3.예약시 주의사항


08월 21일

4. AJAX 사용시 productNum을 파라미터로 쏴야 한다.(productdetail에서)



**살색 컬러**

 rgba(250, 246, 223, 0.89)




08월 22일


결제 API구동하려면.
자바에서 model을 쏴줘야한다
"kto"란 키로 쏠 거임

그걸 html에서 data-로 받는다

그럼 필요한 정보는?
payDTO 
payNum
 
구매자이메일
구매자폰번호 memberDTO에 있는 정보


날짜 정보 DATECLICK시 어떻게 전송할 것인가도 생각해야함.



-----사용한 라이브러리------
javax.mail


날짜 정보 전송.
시간 정보 전송
java.util.date
java.sql.date

SimpleDateFormat클래스로 처리 완료
예약 insert가능하게 됨



-----------8월 23일-----------

문제 1:
오늘 첫째로 부딪힌 문제는 시작 시간. 종료 시간이 4시간 이하일 경우
4시간 이상 해달라는 얼럿 띄우기

해결: 
select에 아이디 주고
$('#selectEndTime option:selected').val()로 값을 가져올 수 있었음.
단, for문은 돌려야 함

그 후 문자열 일부를 잘라서 조건을 걸었음
조건식에 변수를 넣으면 사업자가 원하는 최소 시간대도 설정 가능


문제 2:
또 풀어야할 건
달력 일정 잠궈두기.

임시 해결: fullcalendar의 validRange로 임시 설정.
오늘 전까지의 날짜가 보이지 않게 되고,
선택하거나 클릭할 수도 없게 되었다.

하지만, 날짜는 보이게 하는 게 시각적으로는 더 보기 좋을 것 같아서(비활성화된 날짜가 회색으로 닫혀있어서 칙칙함)
나중에 다시 해결할 예정 

더 급한 문제가 많아서 보류했다.




문제 3: 동의해야만 결제창 (모달)띄우기
해결 : data-bs-target값 변동시켜서 성공


문제 4: 
결제 긁으면 DB에 적용되는지 테스트
DB에 insert하려면 필요한 값
orderNum 
productNum
아직 다른 부분이 없으니 컨트롤러에서 넣어줄예정

구매자 ID  buy_id로받으면 될듯 
payamount amount로 받아올예정



--------------------8월 24일------------------------------
마침내 결제 insert에는 성공했다.
오늘의 핵심: 환불 관련 DB설정 및 결제완료창 띄우기

문제 1: 환불하기
환불하기를 누르면
기존 결제정보가 뜨면서
환불하시겠냐고 묻는창을 띄워야겠다.

그러려면 결제완료창을 먼저 구현해야겠다는 생각이 들었다.

문제 2 : 결제 완료
결제창에 필요한 결제정보

결제한 사람   member 이름
결제수단  이건 파라미터로 받아야됨
결제금액/시간   총금액/시간   시간은 book 끝시간에서 처음시간 빼기
결제날짜 paydate에 있음

결제 완료하면 마이페이지 결제내역으로 가던가.
그담에 결제내역은 마이페이지에서 ajax으로 따로 띄우는거지






문제3 :
주문번호 따로만들기

해결: 자바에서 랜덤 함수 사용
(실제로 필요한가는 고려해보고 적용해야겠다.)
주문번호 말고 결제번호에만 적용하는건어떤가싶음
api와 관련하여 걸리는 게 없는지 생각해야 할듯

문제 4: 
BOOK테이블의 STATUS가 예약->예약 승인 상태로 바뀌어야 결제되게끔
paycontroller나중에 추가해줘야함

status는 예약만 한건지, 승인까지 된건지 체크용.
payment paystate는 1이면 결제 대기(예약)
2면 결제 완료
3이면 환불이라 가정.

적립금 3%

환불 시 업데이트해야 하는 내용
paystate 




({
          url: "https://api.iamport.kr/payments/cancel",
          method: "post",
          headers: {
            "Content-Type": "application/json",
            "Authorization": access_token // 포트원 서버로부터 발급받은 엑세스 토큰
          },
          data: {
            reason, // 가맹점 클라이언트로부터 받은 환불사유
            imp_uid, // imp_uid를 환불 `unique key`로 입력
            amount: cancel_request_amount, // 가맹점 클라이언트로부터 받은 환불금액
            checksum: cancelableAmount // [권장] 환불 가능 금액 입력
          }
        });

오늘 요약: 결제랑 결제 완료페이지까지 진행 완료. 
URL커넥션을 이용해서 내일 환불을 만들어야겠다


------------------8월 25일--------------------

문제 1: 환불 토큰만 받아오기

해결 : json형태로 HttpsURLConnetion을 활용하여 토큰을 받아왔다.

문제 2 : 환불하기
환불을 하려면 토큰과 imp_uid가 필요하단 것을 이제야 깨달았다.
imp_uid를 저장할 컬럼을 DTO에 결제정보에 추가했다.

imp_uid는 sid(서버 아이디)로
merchant_uid는 cid(클라이언트 아이디)로 


그 김에, import에서 어떤 정보들이 넘어오는가도 확보했다.

 {
        "amount": 100,
        "apply_num": null,
        "buyer_addr": "서울 광진구 화양동 xxxx",
        "buyer_email": "xxx@gmail.com",
        "buyer_name": "xxx",
        "buyer_postcode": "143-193",
        "buyer_tel": "010-xxxx-xxxx",
        "cancel_amount": 0,
        "cancel_reason": null,
        "cancel_receipt_urls": [ ],
        "cancelled_at": 0,
        "card_name": null,
        "card_quota": 0,
        "currency": "KRW",
        "custom_data": null,
        "escrow": false,
        "fail_reason": "F0004:PG사 결제요청에 실패하여 중단합니다(imp_092684221544) 결제모듈 재설치필요:",
        "failed_at": 1478732906,
        "imp_uid": "imp_092684221544",
        "merchant_uid": "merchant_1478732608219",
        "name": "주문명:test#1",
        "paid_at": 0,
        "pay_method": "trans",
        "pg_provider": "html5_inicis",
        "pg_tid": null,
        "receipt_url": "https://iniweb.inicis.com/DefaultWebApp/mall/cr/cm/mCmReceipt_head.jsp?noTid=&noMethod=1",
        "status": "failed",
        "user_agent": "sorry_not_supported_anymore",
        "vbank_date": 0,
        "vbank_holder": null,
        "vbank_name": null,
        "vbank_num": null
      },

해결: 기나긴 씨름 끝에 해결
카톡 알림으로 결제가 취소되었단 내용을 받았다.
이제 문제는 결제취소로 받아온 정보에서 결제가 취소가 취소된 거에 대한 처리를 해야한다.


문제 3: 환불 후처리
rgb(32, 12, 121)



-- 8월 26일~27일---

주말동안 API 3개를 정복해보기로했다.

1. 네이버 로그인API
2. 사업자 등록번호 API(data.go.kr로 진행할 예정)
3. 휴대폰 본인인증 API(네이버 클라우드로 진행할 예정)

2,3번은 생각보다 금방 끝났는데, SNS로그인이 길어졌다.

네이버 로그인 순서(scribejava의 servicebuilder와 OAuth20Service사용)
1. 우리 서버에 로그인 요청
2. 서버는 네이버 로그인 페이지 내려보냄
3. 네이버 로그인 수행
4. 네이버에서 처리 결과 code를 calback URL로 보냄
5.받은 Code로 access Token 가져오기
6. access Token으로 profile 정보 가져오기
7. naverid로 member 테이블 체크
(있으면 로그인 처리, 없으면 가입시키고 로그인 처리)



----------8월 28일 ----
refundCheck컬럼을 추가하여
환불 미승인 
환불 완료(승인)
으로 나누기로 함.

네이버로그인 하루종일 했다.
OAuth20Service을 빌더하고
ID 이름, 이메일 받는것에 성공

집에 와서 확인해보니
네이버 

--- 8월 29일 --
아임포트에도 환불 기능이 있지만,
반드시 환불 기능을 홈페이지 쪽에서 구현해야만 하는 이유

1. 관리자 부재 시 일정 기간 내 자동 환불되어야 함 
2. 잘못 눌러서 바로 결제취소를 하는 경우
3. 이렇듯 자동 환불해야할 상황들이 있음.
4. 관리자가 환불이유를 보고 환불해야 함(테이블의 필요성)

그러므로 환불은 구현해놔야 했다.



결제 배경색
#F8F9FA


결제창을 다듬고 있는데 문제 발생.
문제 1 : samesite cookie이슈로 결제창이 안열림.
크롬 samesite 디폴트가 Lax라서 생기는 문제.
버전 문제로 스프링에 response.getHeaders() 메서드도 없어서 어떤 방법으로
samesite=none을 만들어주는가가 문제였다.

스프링 프레임워크 버전도 안 맞아서인지
org.springframework.http.ResponseCookie도 이용할 수 없었다


document.cookie = "cookie1=soo; SameSite=Lax"; 
document.cookie = "cookie2=soo"; 
document.cookie = "cookie3=hoo; SameSite=None; Secure";


그러나 다 의미가 없었고,
결국 문제는 주문번호(Merchant_uid)였다.

결제가 완료되었을 때에는 이미 결제가 완료된 건이라는 창이 떴었는데,
환불까지 완료되고 나니
포트창이 아예 안 뜬 것.



---8월 30일----

예약 상세
결제 상세
둘 다 있는 게 좋긴 할듯.

결제 디테일에서는 내용을 전부 끌어오긴 함.

그렇다면 예약 상세는?

어느쪽이 주축이 되는가.

파트너는 상품을 가진다.
상품은 예약을 가진다.
예약은 결제를 가진다

멤버는 예약을 가진다

이 점을 명심해서 정보를 가져오면 될듯

결제추가에 필요한 테이블 
partner
product
book


결제상세에 필요한 테이블
payment
book
member


--8월 31일 --

DB쪽이 어느 정도 정리가 될 무렵.
SNS로그인도 완성했다.

유저의 프로필 정보를 받아오는 것까지 완료했으나,
금세 문제에 봉착했다.

도출한 의문점들을 이러했다.

1. 소셜 로그인 테이블을 따로 둬야 할지.
2. 만약 테이블을 따로 둔다면 어떤 컬럼들로 구성해야할지.


고민하면서+

관리자 페이지 제작에 들어갔다.



--9월 1일--

오늘은 중요한 중간점검.
깃헙을 합치기로 한 날이다.
2주 후인 15일에 발표를 해야하기 때문에 미리 조율하는 것이 필요했다.

--합치는 순서--
첫번째 로그인 
두번째 마이페이지
세번째 프로덕트
네번째 문의사항.리뷰

네이버 테이블만 
고민할거야.


이메일
아이디
이름
전화번호

네이버테이블 만든다치고


1.네이버테이블
2.이메일도메인 합치기 컨트롤러
3. 카카오 전화번호 받기



에러 고친 후 아이디찾기 확인


<<<<<<< HEAD
package com.ham.main.util.auth;

import java.util.UUID;

import javax.servlet.http.HttpSession;

import org.springframework.util.StringUtils;

import com.github.scribejava.core.builder.ServiceBuilder;
import com.github.scribejava.core.model.OAuth2AccessToken;
import com.github.scribejava.core.model.OAuthRequest;
import com.github.scribejava.core.model.Response;
import com.github.scribejava.core.model.Verb;
import com.github.scribejava.core.oauth.OAuth20Service;

public class KakaoLoginBO {
	
	//카카오 로그인 정보
	private final static String KAKAO_CLIENT_ID = "afe2f18ae504e6a6e246ffaf5a595455";
	private final static String KAKAO_CLIENT_SECRET = "u1ddJi6GhEtAD71RgYkWCSatNgKaWIHu";
	private final static String KAKAO_REDIRECT_URI = "http://localhost:8081/member/callbackKakao.do";
	private final static String SESSION_STATE = "kakao_oauth_state";
	private final static String PROFILE_API_URL = "https://kapi.kakao.com/v2/user/me";
	
	public String getAuthorizationUrl(HttpSession session) {
		String state = generateRandomString();
		setSession(session, state);
		OAuth20Service oauthService = new ServiceBuilder(state)
			.apiKey(KAKAO_CLIENT_ID)
			.apiSecret(KAKAO_CLIENT_SECRET)
			.callback(KAKAO_REDIRECT_URI)
			.state(state).build(KakaoAPI20.instance());
		return oauthService.getAuthorizationUrl();
	}
	
	public OAuth2AccessToken getAccessToken(HttpSession session, String code, String state) throws Exception {
		String sessionState = getSession(session);
		if (StringUtils.pathEquals(sessionState, state)) {
			OAuth20Service oauthService = new ServiceBuilder()
				.apiKey(KAKAO_CLIENT_ID)
				.apiSecret(KAKAO_CLIENT_SECRET)
				.callback(KAKAO_REDIRECT_URI)
				.state(state).build(KakaoAPI20.instance());
			OAuth2AccessToken accessToken = oauthService.getAccessToken(code);
			return accessToken;
		}
		return null;
	}
	
	public String getUserProfile(OAuth2AccessToken oauthToken) throws Exception {
		OAuth20Service oauthService = new ServiceBuilder()
			.apiKey(KAKAO_CLIENT_ID)
			.apiSecret(KAKAO_CLIENT_SECRET)
			.callback(KAKAO_REDIRECT_URI)
			.build(KakaoAPI20.instance());
		OAuthRequest request = new OAuthRequest(Verb.GET, PROFILE_API_URL, oauthService);
		oauthService.signRequest(oauthToken, request);
		Response response = request.send();
		return response.getBody();
	}
	
	private String generateRandomString() {
		return UUID.randomUUID().toString();
	}

	private void setSession(HttpSession session, String state) {
		session.setAttribute(SESSION_STATE, state);
	}

	private String getSession(HttpSession session) {
		return (String)session.getAttribute(SESSION_STATE);
	}

}



<!-- KakaoLoginBO Class에 대한 Bean설정 추가 -->
	<beans:bean id="SNSLogin" class="com.ham.main.util.auth.SNSLogin" />
	
	<context:component-scan base-package="com.ham.main" />
	
=======

--9월 2일---

팀원들과 합치면서 할일이 엄청 많아졌다.
비교적 DB나 라이브러리, 해당 웹사이트 구조 이해도가 제일 높은 내가 합치기로 마음먹었고,
합치는 순서는 나(결제 환불)를 기준으로 멤버(로그인 기능)->상품->마이페이지->문의,후기
순이었다.


1. 우선 카카오 로그인 코드를 네이버에 병합해야했다.
2.  그리고 자잘하게 신경써야할 것.
2-1. 상품 상세에 예약하기 창 넣기
2-2. 마이페이지에 결제 환불 상세내역 ajax로 추가하기
2-3. 상품에 문의, 후기 추가하기


Fork한 것을 merge하고 다시 branch를 뿌려서 팀원들에게 나눠주는 것 자체도 처음 해보는 일이었기에,
아주 소중한 시간이었다.

특히, 이 과정은 매우 번거로웠다.
jsp명 대문자소문자 통일(footer)
변수명 대문자소문자 통일

사실상 순수 노가다였기에 손목이 부러져라 복붙했다.

거기서 드는 의문점..

팀원들이 각자 자기 의도대로 꾸미는 건 좋으나
변수명이나 파일명이 겹치는 부분에서는 어떻게어떻게 하겠다고 말해줘야함.

팀원끼리 거의 소통이 없는 문제가 있었던 것.
팀장인 나는 하루에 1~2시간씩 팀원들을 찾아가 프로젝트 진행 상황에 대해 의견을 나누곤 했다.
그래서 꽤 빈번한 소통이 있었지만,

팀원들끼리는 말 한마디 나누지 않다보니 footer의 파일명(하나는 첫글자가 대문자였음)조차 일치하지 않는 문제가 발생.

이에 대해서는 말을 해둬야겠다.

업데이트 사항

1. sql문 
2. DB 예시 10개씩 추가
3. 상품번호 주문번호
4. IMP_UID 결제번호 시퀀스에 합치기


일단 윤호 씨는 파트너 로그인 관련해서 추가++
role이 2인 경우 로그인되게 만들어주시고, 파트너로그인 메서드 합쳐주시고, 끝나면 파트너 페이지 만들어주세요.


윤제 씨랑 재혁 씨는 서로 논의해서 상품 상세에 문의랑 후기 어떻게 넣을지 얘기한 후에 ajax로 넣어주시고,
question List, review List를 상품 상세에서 볼 수 있게 해주세요.


재혁 씨는 상품 상세에서
상품값 ','이 들어가도 숫자로 바뀔수있는 방법 고려해주시고, 키 값 dto->kto로 맞춰주시고,  상품 디테일, 리스트 CSS 많이 꾸며주셔야 되요
그리고 실제 DB랑 resource에 업로드해서 저장할 상품 데이터랑 사진들 모아주세요. 최소 11개 이상 필요합니다.

윤제 씨도 마찬가지로 실제 DB에 저장할 후기랑 문의 데이터 6개 이상 모아주세요.
sql구문은 대문자로 써주시고, question list랑, review list에 add버튼 넣어주세요.


민준 씨는 마이페이지 내정보관리 부분 완성해주시고 info랑 checkinfo 정리해주세요.



이외에도 변수명 일정하게 맞춰주세요. 
백엔드는 카멜방식.
sql부분은 대문자.
프론트엔드는 카멜이나 스네이크방식.(부트스트랩 때문에 되도록 스네이크로)
변수명도 memDTO->memberDTO로 해주시고요. 

자바스크립트는 JS에 폴더명 나눠서 경로가 구분되게 저장해주세요.


그리고 변수명 일정하게 맞춰주세요. 
앞으로 DB사용하실 때 model의 key값은 kto로 고정, memberDTO의 key값은  member로 고정입니다
2개 이상의 변수를 model이나 session에 넣어야 하면, DTO를 뺀 클래스명으로 해주세요.
예시> DTO가 2개인 경우 product, book

이제 로그인 기능 있으니,
컨트롤러에서 id를 참조하는 기능들(상품,마이페이지,문의, 후기)은  session.getAttribute로 멤버 꺼내서 구현 진행해주시고,

주의할 점으로는 아이디 찾기에서 휴대폰 본인인증은 함부로 사용하지 말아주세요.
(이거 돈 나갑니다)

지금 테이블명이랑 컬럼명, 인스턴스 변수명 죄다 최대한 맞춰놓았으니까
변경하시려면 저한테 반드시 물어보신 후에 추가하거나 없애주시기 바랍니다.

주말이지만 시간이 촉박하니 공지를 조금(?) 드리겠습니다

1. 상품 - 문의 후기 연결
2. 상품 - 예약 - 결제 연결
3. 




유의할점
4. js폴더에 넣어줄것


>>>>>>> bf5a4614575952200f55005a55c1a20925dfd9bc




--9월 4일--

사용시간이 안찍힌다
찍었던 10시부터 18시.
조금 수정해야겠다.


book/list에서
승인상태 0이면 미승인
1이면 예약 승인 뜨게하기



--9 월 6일--

어제는 바쁘고 몸살이심해서 일지쓸여유가없었다.
오늘 당면한 문제는 여전히 새로운 것들이었다.

1.
첫째는 파트너의 예약관리 창에서
어떻게
여러개 상품에서 데이터를 뽑아서 그대로
 list로 보내주는가가 관건이었다.

partnerNum으로 상품을 가져오고
그 상품마다 걸린 예약들을 가져온다.


그 값이 list인데, 다시 for문을 돌려서
list.add로 값들을 하나씩 넣은 후에 model에 보내주었다


2.
미승인 된 건은 달력 클릭 시에 리스트로 나오고
승인된 건은 달력에 체크가 되어있어야 한다.

페이저 넣어주면서 자바스크립트에서 그 내용을 받아서 이벤트로넣을 생각.


[{start=Wed Sep 13 16:00:00 KST 2023, end=Wed Sep 13 20:00:00 KST 2023, id=id1}, {start=Wed Sep 13 16:00:00 KST 2023, end=Wed Sep 13 20:00:00 KST 2023, id=id1}, {start=Wed Sep 13 16:00:00 KST 2023, end=Wed Sep 13 20:00:00 KST 2023, id=id1}]

달력도 같이 꾸며주면서 
1,2번을 70%정도 완료했다.
나머진 내일 해야지.

--9월 7일--

예약 승인 관리 페이지//

배열로 넣어주어서 이벤트가 나오긴했는데.
어째서인지 날짜가 13일로 고정되어 있었다.

6일 날짜 예약치는 6일에 찍혀야 한다.

(해결: 반복문 값을 넣어주는 Map을 for문 안에 넣었어야했는데 안넣고해서 그런거였다)




참고로 빈페이지에서는 (AJAX전송) 예약 내역이 없습니다 라고
텍스트가 나오게하자.

전달 사항은 모달로 볼 수 있게끔




환불 규정에 맞게 환불메서드실행.
하게 해야함.



let contentsList =[]
$('btn-contents').attr('data-contents')
$('.modal-body').html(${i.contents});
contentsList.push($('btn-contents').attr('data-contents'));


이미 예약된 정보는 
예약 달력에 체크해서 못하게 해야함.
.
시간대도 마찬가지




예약페이지//

이용 시간에서 ajax를 쏴서 시작시간 종료시간에 

option에서
해당 시간 X추가

예약된 시간 누르면 '이미 예약된 시간대입니다.'
라고
출력

bookcheck가 승인상태일때,
start end 시간 받아와서 보내주면됨.

보내는 데이터는 date bookdate
받는 데이터는 book전체

booklist가져와야함.


selectMirror: true


String str = "2019/05/01 00:59:29";
SimpleDateFormat formatter = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
Date strToDate = null;

Thu Sep 21 2023 00:00:00 GMT+0900

Thu Sep 14 2023 00:00:00 GMT+0900 (한국


--9월 8일---

마무리 단계로 접어들려고 한다.

해야할일을 쭉 정리해보도록 했다.

결제쪽:
시간당 얼마 넣는 것도 계산해야함


환불쪽: 
환불을 신청하고 기다려야하는 경우(당일날 이후) ,
환불 이틀 전에는 총 금액의 70%만 환불되게끔 하고
나머지는 바로 환불(refundcheck가 바로 1이되어야함)

지난 내역에서 환불한 건은
환불하기 버튼이 이미 환불하셨습니다로 바뀌어야 함

setperpage3개씩?
페이징



---9월9일~10일---

눈코뜰새없이 바빴다.
아침 8시부터 저녁 10시까지 무호흡 개발.

집중해서 하다보면 어느새 밤이다.

오전에 4개 브런치를 흡수해서 머지를 완료했고, 
거의발전이 없던 product/list와 detail을 80% 완성시켰다.

그렇게 토요일이 흘러갔고,
일요일에는 오전에 해야할 일이 메인 홈 완성하기.

그리고 결제에 시간*가격넣기
환불이 바로되게끔 설정하기

이 2가지 기본 기능들을 추가해야했다.

테이블에서 point도빼야함


환불->로직을 더 정확히 구체화하면

일단, 바로 환불이 되려면
refundCheck가 0보다 커야 한다.

그러므로 예약일자가 환불을 신청한 현재보다 4일 전까지면
refundCheck가 1이 되게 if조건 걸어주기.

아니라면 default(refundCheck=0)
완료

이제 환불 기능 확인 후

환불 승인 파트너 쪽에서 구현



--9월 14일 --

발표 당일 전날.

수정사항들이 좀 있다.
발표준비는 못하겠지만


1. 관리자 상품수정 삭제되게해야하고

2.리뷰파일 등록 조회가능하게
3. 4일전 환불조건 다시확인하고 제대로 작동하는지 시연해보기
5.결제 카카오페이 이니시스(2가지)로 테스트해보기





---9월 11일---

안정화 작업중 안되는것들을 찾아서 해결하고있다.





--9월 12일--
일주일간 고생했던 결제내역 환불내역의 페이저...
수많은 헤딩을 하고 고민한 끝에 마침내 아이디어가 번쩍 떠올랐다.

페이저에 조인을 추가하는 것.

이 간단한 걸 왜 어렵게 생각한건지..
지금 생각해보면 바보같기도 하지만 
그 누구의 도움도 없이 풀어냈다는 사실이 뿌듯하기도 하고 기분좋다




	<!-- 한 행에 3개의 제품을 배치하려면 여기까지 3번 반복 -->
				<!-- 예를 들어, i.index % 3 === 2 조건을 사용하여 한 행을 마감할 수 있습니다. -->
				<c:if test="${i.index % 3 == 2}">
			</div>
			</div>
			</div>
			<div class="row">
				</c:if>


--9월 13일--

snslogin의 디테일한 문제들을 잡아주니깐 시간이 다갔다.
이메일이 같고, 플랫폼이 같은경우

이런경우는 걍-> 로그인시키면됨

이메일이 같고, 플랫폼이 다른경우
이런 경우는 이미 사용하는 이메일입니다 메세지 띄워주고 홈

등등


9월 14일--
최종 수정

1. 관리자 상품 수정 삭제되게
2. 리뷰파일 추가 수정 되게하기
3.  예약 4일전 환불조건 코딩 다시확인하고
제대로 작동하는지 시연해보기
4. 카카오페이 이니시스로 테스트해보기


그 사람이 해당 공간을 결제한 내역이 있어야만해.






